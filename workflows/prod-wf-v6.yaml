apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: production-pipeline-with-rollout-01
  namespace: argo
spec:
  entrypoint: main-pipeline
  serviceAccountName: workflow-executor

  arguments:
    parameters:
    - name: git-repo
      value: https://github.com/vasplustechnologies/easy-nginx-demosite.git
    - name: git-branch
      value: main
    - name: image-version
      value: "1.0.0"

  templates:
  - name: main-pipeline
    steps:
    - - name: clone-repo
        template: git-clone

    - - name: build-image
        template: kaniko-build-push
        arguments:
          parameters:
          - name: git-sha
            value: "{{steps.clone-repo.outputs.parameters.git-sha}}"
          - name: image-version
            value: "{{workflow.parameters.image-version}}"

    - - name: security-scan
        template: security-scan
        arguments:
          parameters:
          - name: image-tag
            value: "mofwili/easy-nginx:{{steps.build-image.outputs.parameters.version-tag}}"
        when: "{{steps.build-image.status}} == Succeeded"

    # âœ… NEW: Argo Rollouts deployment step
    - - name: update-rollout
        template: update-rollout
        arguments:
          parameters:
          - name: image-tag
            value: "mofwili/easy-nginx:{{steps.build-image.outputs.parameters.version-tag}}"
        when: "{{steps.security-scan.status}} == Succeeded"

    - - name: notify-success
        template: slack-notification
        arguments:
          parameters:
          - name: status
            value: "success"
          - name: message
            value: "ğŸš€ Production pipeline completed! Image: mofwili/easy-nginx:{{steps.build-image.outputs.parameters.version-tag}} | Scan: {{steps.security-scan.outputs.parameters.scan-result}} | Deployment: {{steps.update-rollout.outputs.parameters.rollout-status}}"
        when: "{{steps.update-rollout.status}} == Succeeded"

    - - name: notify-failure
        template: slack-notification
        arguments:
          parameters:
          - name: status
            value: "failure"
          - name: message
            value: "âŒ Pipeline failed at: {{steps.security-scan.outputs.parameters.failed-step}}"
        when: "{{steps.security-scan.status}} == Failed"

  # âœ… ALL YOUR EXISTING TEMPLATES REMAIN EXACTLY THE SAME
  - name: git-clone
    container:
      image: alpine/git:latest
      command: [sh, -c]
      args:
      - |
        set -e
        echo "ğŸ“¦ Cloning repository..."
        rm -rf /mnt/workspace/* /mnt/workspace/.* 2>/dev/null || true
        git clone {{workflow.parameters.git-repo}} /mnt/workspace
        cd /mnt/workspace
        git checkout {{workflow.parameters.git-branch}}
        GIT_SHA=$(git rev-parse --short HEAD)
        echo "âœ… Repository cloned. SHA: $GIT_SHA"
        echo "ğŸ“ Workspace contents:"
        ls -la /mnt/workspace/
        echo $GIT_SHA > /tmp/git-sha.txt
      volumeMounts:
      - name: workspace-pvc
        mountPath: /mnt/workspace
    outputs:
      parameters:
      - name: git-sha
        valueFrom:
          path: /tmp/git-sha.txt

  - name: kaniko-build-push
    inputs:
      parameters:
      - name: git-sha
      - name: image-version
    container:
      image: gcr.io/kaniko-project/executor:v1.9.1
      args:
      - --dockerfile=/mnt/workspace/Dockerfile
      - --context=dir:///mnt/workspace
      - --destination=mofwili/easy-nginx:{{inputs.parameters.git-sha}}
      - --destination=mofwili/easy-nginx:{{inputs.parameters.image-version}}-{{inputs.parameters.git-sha}}
      - --destination=mofwili/easy-nginx:{{inputs.parameters.image-version}}
      - --destination=mofwili/easy-nginx:latest
      - --cache=false
      - --single-snapshot
      - --verbosity=info
      - --skip-tls-verify
      env:
      - name: DOCKER_CONFIG
        value: /kaniko/.docker
      volumeMounts:
      - name: workspace-pvc
        mountPath: /mnt/workspace
      - name: docker-config
        mountPath: /kaniko/.docker
    outputs:
      parameters:
      - name: version-tag
        value: "{{inputs.parameters.image-version}}-{{inputs.parameters.git-sha}}"

  - name: security-scan
    inputs:
      parameters:
      - name: image-tag
    container:
      image: aquasec/trivy:latest
      command: [sh, -c]
      args:
      - |
        set -e
        echo "ğŸ”’ Starting comprehensive security scan..."
        echo "ğŸ“¦ Scanning image: {{inputs.parameters.image-tag}}"
        
        # Create reports directory in PERSISTENT storage
        mkdir -p /mnt/workspace/reports

        # Run vulnerability scan - FAIL on CRITICAL vulnerabilities only
        echo "ğŸ” Scanning for CRITICAL vulnerabilities..."
        if trivy image --severity CRITICAL --exit-code 1 --format json --output /mnt/workspace/reports/trivy-critical.json {{inputs.parameters.image-tag}}; then
          echo "âœ… No CRITICAL vulnerabilities found"
          CRITICAL_COUNT=0
        else
          CRITICAL_COUNT=$(cat /mnt/workspace/reports/trivy-critical.json 2>/dev/null | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length' || echo "0")
          echo "âŒ Found $CRITICAL_COUNT CRITICAL vulnerabilities"
        fi

        # Run full vulnerability scan for report (don't fail on HIGH)
        echo "ğŸ” Running full vulnerability scan..."
        trivy image --severity HIGH,CRITICAL --format json --output /mnt/workspace/reports/trivy-full.json {{inputs.parameters.image-tag}} || true
        
        HIGH_COUNT=$(cat /mnt/workspace/reports/trivy-full.json 2>/dev/null | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH")] | length' || echo "0")
        
        echo "ğŸ“Š Security Scan Results:"
        echo "  CRITICAL vulnerabilities: $CRITICAL_COUNT"
        echo "  HIGH vulnerabilities: $HIGH_COUNT"

        # Generate HTML report for better visualization
        echo "ğŸ“„ Generating HTML report..."
        trivy image --format template --template "@contrib/html.tpl" --output /mnt/workspace/reports/trivy-report.html {{inputs.parameters.image-tag}} || true

        # Also generate simple text summary
        echo "Security Scan Summary" > /mnt/workspace/reports/scan-summary.txt
        echo "====================" >> /mnt/workspace/reports/scan-summary.txt
        echo "Image: {{inputs.parameters.image-tag}}" >> /mnt/workspace/reports/scan-summary.txt
        echo "Critical Vulnerabilities: $CRITICAL_COUNT" >> /mnt/workspace/reports/scan-summary.txt
        echo "High Vulnerabilities: $HIGH_COUNT" >> /mnt/workspace/reports/scan-summary.txt
        echo "Scan Date: $(date)" >> /mnt/workspace/reports/scan-summary.txt

        # Quality Gate - FAIL only on CRITICAL vulnerabilities
        if [ "$CRITICAL_COUNT" -gt "0" ]; then
          echo "âŒ QUALITY GATE FAILED: $CRITICAL_COUNT CRITICAL vulnerabilities found"
          echo "critical_vulnerabilities" > /tmp/failed-step.txt
          echo "failed" > /tmp/scan-result.txt
          exit 1
        else
          echo "âœ… QUALITY GATE PASSED: No critical vulnerabilities"
          echo "passed" > /tmp/scan-result.txt
          echo "none" > /tmp/failed-step.txt
        fi
        
        echo "ğŸ“ Reports saved to persistent storage: /mnt/workspace/reports/"
        echo "ğŸ“‹ Available reports:"
        ls -la /mnt/workspace/reports/
      volumeMounts:
      - name: workspace-pvc
        mountPath: /mnt/workspace
    outputs:
      parameters:
      - name: scan-result
        valueFrom:
          path: /tmp/scan-result.txt
      - name: failed-step
        valueFrom:
          path: /tmp/failed-step.txt
      artifacts:
      - name: security-reports
        path: /mnt/workspace/reports
        archive:
          none: {}  # Keep files as-is, no compression

  # # âœ… NEW: Argo Rollouts template
  # - name: update-rollout
  #   inputs:
  #     parameters:
  #     - name: image-tag
  #   container:
  #     image: argoproj/kubectl-argo-rollouts:latest
  #     command: [sh, -c]
  #     args:
  #     - |
  #       set -e
  #       echo "ğŸš€ Starting Argo Rollouts deployment..."
  #       echo "ğŸ“¦ Deploying image: {{inputs.parameters.image-tag}}"
        
  #       # Update the rollout with the new image
  #       kubectl argo rollouts set image easy-nginx \
  #         nginx={{inputs.parameters.image-tag}} \
  #         -n easy-nginx
        
  #       echo "âœ… Rollout update initiated!"
  #       echo "ğŸ“Š Rollout status:"
  #       kubectl argo rollouts get rollout easy-nginx -n easy-nginx --watch=false
        
  #       # Get rollout status for notification
  #       ROLLOUT_STATUS=$(kubectl argo rollouts get rollout easy-nginx -n easy-nginx -o jsonpath='{.status.phase}')
  #       echo "Rollout Phase: $ROLLOUT_STATUS"
  #       echo "$ROLLOUT_STATUS" > /tmp/rollout-status.txt
        
  #       echo "ğŸ¯ Canary deployment in progress..."
  #       echo "   25% â†’ 50% â†’ 75% â†’ 100%"
  #       echo "   Monitor with: kubectl argo rollouts get rollout easy-nginx -n easy-nginx --watch"
  #     volumeMounts:
  #     - name: kubeconfig
  #       mountPath: /root/.kube
  #       readOnly: true
  #   outputs:
  #     parameters:
  #     - name: rollout-status
  #       valueFrom:
  #         path: /tmp/rollout-status.txt

  - name: update-rollout
  inputs:
    parameters:
    - name: image-tag
  container:
    image: bitnami/kubectl:latest  # Use standard kubectl + manual plugin install
    command: [sh, -c]
    args:
    - |
      set -e
      echo "ğŸš€ Setting up Argo Rollouts plugin..."
      
      # Install argo-rollouts kubectl plugin manually
      curl -LO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
      chmod +x kubectl-argo-rollouts-linux-amd64
      mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts
      
      echo "âœ… Argo Rollouts plugin installed"
      echo "ğŸ“¦ Deploying image: {{inputs.parameters.image-tag}}"
      
      # Update the rollout with the new image
      kubectl argo rollouts set image easy-nginx \
        nginx={{inputs.parameters.image-tag}} \
        -n easy-nginx
      
      echo "âœ… Rollout update initiated!"
      echo "ğŸ“Š Rollout status:"
      kubectl argo rollouts get rollout easy-nginx -n easy-nginx --watch=false
      
      # Get rollout status for notification
      ROLLOUT_STATUS=$(kubectl argo rollouts get rollout easy-nginx -n easy-nginx -o jsonpath='{.status.phase}')
      echo "Rollout Phase: $ROLLOUT_STATUS"
      echo "$ROLLOUT_STATUS" > /tmp/rollout-status.txt
      
      echo "ğŸ¯ Canary deployment in progress..."
      echo "   25% â†’ 50% â†’ 75% â†’ 100%"
    volumeMounts:
    - name: kubeconfig
      mountPath: /root/.kube
      readOnly: true
  outputs:
    parameters:
    - name: rollout-status
      valueFrom:
        path: /tmp/rollout-status.txt

  - name: slack-notification
    inputs:
      parameters:
      - name: status
      - name: message
    container:
      image: curlimages/curl:latest
      command: [sh, -c]
      args:
      - |
        set -e
        echo "ğŸ“¨ Preparing Slack notification..."
        
        # Check if webhook URL is set
        if [ -z "$SLACK_WEBHOOK_URL" ]; then
          echo "âš ï¸  SLACK_WEBHOOK_URL not set, skipping notification"
          exit 0
        fi

        # Determine color based on status
        if [ "{{inputs.parameters.status}}" = "success" ]; then
          COLOR="good"
          EMOJI="ğŸš€"
        else
          COLOR="danger"
          EMOJI="âŒ"
        fi

        # Create rich notification payload
        PAYLOAD=$(cat << EOF
        {
          "attachments": [
            {
              "color": "$COLOR",
              "title": "{{inputs.parameters.status}}",
              "text": "{{inputs.parameters.message}}",
              "fields": [
                {
                  "title": "Workflow",
                  "value": "{{workflow.name}}",
                  "short": true
                },
                {
                  "title": "Namespace",
                  "value": "{{workflow.namespace}}",
                  "short": true
                },
                {
                  "title": "Repository",
                  "value": "{{workflow.parameters.git-repo}}",
                  "short": false
                },
                {
                  "title": "Version",
                  "value": "{{workflow.parameters.image-version}}",
                  "short": true
                }
              ],
              "footer": "Argo Workflows",
              "ts": $(date +%s)
            }
          ]
        }
        EOF
        )

        echo "ğŸ“¤ Sending Slack notification..."
        curl -X POST \
          -H 'Content-type: application/json' \
          --data "$PAYLOAD" \
          "$SLACK_WEBHOOK_URL"
        
        echo "âœ… Notification sent successfully!"
      env:
      - name: SLACK_WEBHOOK_URL
        valueFrom:
          secretKeyRef:
            name: slack-webhook
            key: url

  volumes:
  - name: docker-config
    secret:
      secretName: dockerhub-credentials
      items:
      - key: .dockerconfigjson
        path: config.json
  - name: kubeconfig
    secret:
      secretName: workflow-kubeconfig
      items:
      - key: config
        path: config

  volumeClaimTemplates:
  - metadata:
      name: workspace-pvc
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 1Gi